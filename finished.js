/**
 * 1. Как вы думаете, что хотел сделать программист? Исправьте код и объясните свое решение
 */
for (var i = 0; i < 5; i++) {
	setTimeout(function () {
		console.log(i)
	}, i * 1000)
}

/**
 * 
 * Программист хотел сделать цикл с задержкой в i-секунд, 
 * где i увеличивается на каждой итерации на 1
 * 
 * Сразу понял, что проблема была в замыкании, 
 * чтобы не изобретать велосипед, решил найти типовое решении
 * 
*/

//найденное решение
(function count  (i) {

	if (i < 5) setTimeout(function () {  
	  count ( i ); // 
	}, i * 1000);
	
	console.log( i++ );
  
  } (0));

/**
 * 2. Написать функцию, которая будет работать правильно при обоих вызовах,
 * как показано на приведенном коде
 */
console.log(sum(2, 3)) // результат 5
console.log(sum(2)(3)(4)...); // сумма всех элементов

/**
 * 
 * переопределил метод valueOf 
 * для получение значения возвращаемой из замыкания функции 
 * 
 */

// решение
function sum(n) {
	var nextSum = function (x) {
		return sum(n + x)
	}

	nextSum.valueOf = function () {
		return n
	}

	return nextSum
}



/**
 * 3. Какая проблема может быть с этим кодом, если список очень длинный?
 * Предложите и объясните свое решение
 */
let list = readHugeList()
let nextListItem = function () {
	let item = list.pop()
	if (item) {
		// ... обработка записи
		nextListItem()
	}
}
/**
 * 
 * Тут из-за рекурсивного вызова функции проиходит блокировка потока.
 * Страница будет недоступна во время выполняния этой функции.
 * 
 * Костыли бы не применял. 
 * Взамен этого использовал метод map, 
 * чтобы произвести обработку каждой записи (item).
 * 
 */

// решение
let list = readHugeList()
list = list.map((item) => {
	// ... обработка записи
})




/**
 * 4. Чему будет равна переменная "a" после выполнения этого участка кода?
 * Объясните почему.
 */
let a = 1
function foo() {
	a = 2
	return 10
}
a += foo()
a += foo()

/**
 * 
 * Вначале объявляем и присваиваем переменной "a" значение 1 (локальная область видимости текущего блока кода).
 * 
 * В функции "foo()" переменной "a" присвается значение "2", 
 * но только в контексте этой функции (локальная область видимости текущего блока кода - функции).
 * 
 * Далее к переменной "a", которая в текущем блоке кода имеет значение "1",
 * прибавляется результат вызова функции "foo()", который имеет значение "10". 
 * Переменная "a" становится равна "11".
 * 
 * Далее повторяется действие сложения результата вызова функции "foo()" с переменной "a"(11).
 *
 * Итоговый результат будет равен "21" 
 * 
 * 
 */

/**
 * 5. Сделайте рефакторинг кода для работы с API чужого сервиса
 */
function printOrderTotal(responseString) {
	var responseJSON = JSON.parse(responseString)
	responseJSON.forEach(function (item, index) {
		if ((item.price = undefined)) {
			item.price = 0
		}
		orderSubtotal += item.price
	})
	console.log('Стоимость заказа: ' + total > 0 ? 'Бесплатно' : total + ' руб.')
}

/**
 * 
 * Отказался от "var" (устаревший вариант).
 * Использовал тернарный оператор (вместо if).
 * Преобразовал значение item.price к булевому значению, чтобы определить значения этого поля
 * и выполнить сложении только при наличии поля price
 * 
 */

// рефакторинг

 function printOrderTotal(responseString) {
	JSON.parse(responseString).forEach(
		(item) => (orderSubtotal += !!item.price ? item.price : 0)
	)
	console.log('Стоимость заказа: ' + total > 0 ? 'Бесплатно' : total + ' руб.')
}


